// Code generated by MockGen. DO NOT EDIT.
// Source: internal/executor/agent_executor.go
//
// Generated by this command:
//
//	mockgen -source=internal/executor/agent_executor.go -destination=internal/executor/mocks/mock_executor.go -package=mocks
//

// Package mocks is a generated GoMock package.
package mocks

import (
	context "context"
	reflect "reflect"

	models "github.com/povarna/generative-ai-with-go/eval-agent/internal/models"
	gomock "go.uber.org/mock/gomock"
)

// MockPrecheckRunner is a mock of PrecheckRunner interface.
type MockPrecheckRunner struct {
	ctrl     *gomock.Controller
	recorder *MockPrecheckRunnerMockRecorder
	isgomock struct{}
}

// MockPrecheckRunnerMockRecorder is the mock recorder for MockPrecheckRunner.
type MockPrecheckRunnerMockRecorder struct {
	mock *MockPrecheckRunner
}

// NewMockPrecheckRunner creates a new mock instance.
func NewMockPrecheckRunner(ctrl *gomock.Controller) *MockPrecheckRunner {
	mock := &MockPrecheckRunner{ctrl: ctrl}
	mock.recorder = &MockPrecheckRunnerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockPrecheckRunner) EXPECT() *MockPrecheckRunnerMockRecorder {
	return m.recorder
}

// Run mocks base method.
func (m *MockPrecheckRunner) Run(evalCtx models.EvaluationContext) []models.StageResult {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Run", evalCtx)
	ret0, _ := ret[0].([]models.StageResult)
	return ret0
}

// Run indicates an expected call of Run.
func (mr *MockPrecheckRunnerMockRecorder) Run(evalCtx any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Run", reflect.TypeOf((*MockPrecheckRunner)(nil).Run), evalCtx)
}

// MockJudgeRunner is a mock of JudgeRunner interface.
type MockJudgeRunner struct {
	ctrl     *gomock.Controller
	recorder *MockJudgeRunnerMockRecorder
	isgomock struct{}
}

// MockJudgeRunnerMockRecorder is the mock recorder for MockJudgeRunner.
type MockJudgeRunnerMockRecorder struct {
	mock *MockJudgeRunner
}

// NewMockJudgeRunner creates a new mock instance.
func NewMockJudgeRunner(ctrl *gomock.Controller) *MockJudgeRunner {
	mock := &MockJudgeRunner{ctrl: ctrl}
	mock.recorder = &MockJudgeRunnerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockJudgeRunner) EXPECT() *MockJudgeRunnerMockRecorder {
	return m.recorder
}

// Run mocks base method.
func (m *MockJudgeRunner) Run(ctx context.Context, evalCtx models.EvaluationContext) []models.StageResult {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Run", ctx, evalCtx)
	ret0, _ := ret[0].([]models.StageResult)
	return ret0
}

// Run indicates an expected call of Run.
func (mr *MockJudgeRunnerMockRecorder) Run(ctx, evalCtx any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Run", reflect.TypeOf((*MockJudgeRunner)(nil).Run), ctx, evalCtx)
}

// MockAggregator is a mock of Aggregator interface.
type MockAggregator struct {
	ctrl     *gomock.Controller
	recorder *MockAggregatorMockRecorder
	isgomock struct{}
}

// MockAggregatorMockRecorder is the mock recorder for MockAggregator.
type MockAggregatorMockRecorder struct {
	mock *MockAggregator
}

// NewMockAggregator creates a new mock instance.
func NewMockAggregator(ctrl *gomock.Controller) *MockAggregator {
	mock := &MockAggregator{ctrl: ctrl}
	mock.recorder = &MockAggregatorMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockAggregator) EXPECT() *MockAggregatorMockRecorder {
	return m.recorder
}

// Aggregate mocks base method.
func (m *MockAggregator) Aggregate(id string, stage1, stage2 []models.StageResult) models.EvaluationResult {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Aggregate", id, stage1, stage2)
	ret0, _ := ret[0].(models.EvaluationResult)
	return ret0
}

// Aggregate indicates an expected call of Aggregate.
func (mr *MockAggregatorMockRecorder) Aggregate(id, stage1, stage2 any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Aggregate", reflect.TypeOf((*MockAggregator)(nil).Aggregate), id, stage1, stage2)
}
