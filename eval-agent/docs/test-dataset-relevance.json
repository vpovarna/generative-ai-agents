{
  "judge_name": "relevance",
  "description": "Test dataset for RelevanceJudge - evaluates whether the answer addresses the user's query",
  "test_cases": [
    {
      "id": "rel-001",
      "name": "Direct technical answer - perfect relevance",
      "expected_score_range": "0.8-1.0",
      "event_id": "evt-rel-001",
      "event_type": "agent_response",
      "agent": {
        "name": "kg-agent",
        "type": "rag",
        "version": "1.0.0"
      },
      "interaction": {
        "user_query": "How do I encrypt files using AES?",
        "context": "AES (Advanced Encryption Standard) is a symmetric encryption algorithm. In Go, you can use the crypto/aes package to encrypt files. The process involves creating a cipher block, choosing a mode (like GCM or CBC), and applying it to your data.",
        "answer": "To encrypt files using AES in Go, you need to: 1) Import crypto/aes and crypto/cipher packages, 2) Generate a 32-byte key, 3) Create an AES cipher block using aes.NewCipher(), 4) Choose a mode like GCM for authenticated encryption, and 5) Apply the cipher to your file data. Here's a basic example that demonstrates the encryption process."
      }
    },
    {
      "id": "rel-002",
      "name": "Partial answer - medium relevance",
      "expected_score_range": "0.5-0.7",
      "event_id": "evt-rel-002",
      "event_type": "agent_response",
      "agent": {
        "name": "kg-agent",
        "type": "rag",
        "version": "1.0.0"
      },
      "interaction": {
        "user_query": "What are the performance implications of using interfaces in Go?",
        "context": "Interfaces in Go provide abstraction and polymorphism. They have some performance overhead due to dynamic dispatch and indirect method calls.",
        "answer": "Interfaces are an important feature of Go that enable polymorphism and clean architecture. They allow you to write flexible, testable code by depending on abstractions rather than concrete types."
      }
    },
    {
      "id": "rel-003",
      "name": "Completely irrelevant answer",
      "expected_score_range": "0.0-0.3",
      "event_id": "evt-rel-003",
      "event_type": "agent_response",
      "agent": {
        "name": "kg-agent",
        "type": "rag",
        "version": "1.0.0"
      },
      "interaction": {
        "user_query": "How do I configure Redis connection pooling?",
        "context": "Redis is an in-memory data store. Connection pooling helps manage database connections efficiently.",
        "answer": "PostgreSQL is a powerful relational database that supports ACID transactions and complex queries. It's widely used in enterprise applications."
      }
    },
    {
      "id": "rel-004",
      "name": "Multi-part question - fully addressed",
      "expected_score_range": "0.8-1.0",
      "event_id": "evt-rel-004",
      "event_type": "agent_response",
      "agent": {
        "name": "kg-agent",
        "type": "rag",
        "version": "1.0.0"
      },
      "interaction": {
        "user_query": "What's the difference between buffered and unbuffered channels, and when should I use each?",
        "context": "Go channels can be buffered or unbuffered. Unbuffered channels block until both sender and receiver are ready. Buffered channels allow sending without immediate receiver, up to the buffer size.",
        "answer": "Unbuffered channels (created with make(chan T)) require both sender and receiver to be ready, providing synchronization. Buffered channels (make(chan T, n)) allow n values to be sent without blocking, useful for producer-consumer patterns. Use unbuffered when you need strict synchronization, and buffered when you want to decouple sender/receiver or handle bursts of data."
      }
    },
    {
      "id": "rel-005",
      "name": "Multi-part question - partially addressed",
      "expected_score_range": "0.4-0.6",
      "event_id": "evt-rel-005",
      "event_type": "agent_response",
      "agent": {
        "name": "kg-agent",
        "type": "rag",
        "version": "1.0.0"
      },
      "interaction": {
        "user_query": "What's the difference between REST and gRPC, and which is better for microservices?",
        "context": "REST uses HTTP/1.1 with JSON, while gRPC uses HTTP/2 with Protocol Buffers. Both are used in microservices architectures.",
        "answer": "REST is an architectural style that uses HTTP methods and JSON for data exchange. It's widely adopted and easy to use with standard HTTP clients. gRPC uses Protocol Buffers which are more compact than JSON."
      }
    },
    {
      "id": "rel-006",
      "name": "Vague question - reasonable interpretation",
      "expected_score_range": "0.6-0.8",
      "event_id": "evt-rel-006",
      "event_type": "agent_response",
      "agent": {
        "name": "kg-agent",
        "type": "rag",
        "version": "1.0.0"
      },
      "interaction": {
        "user_query": "How do I make it faster?",
        "context": "Previous conversation discussed database query performance. User mentioned slow SELECT queries with multiple JOINs.",
        "answer": "To improve your database query performance, consider: 1) Adding indexes on columns used in JOIN and WHERE clauses, 2) Using EXPLAIN to analyze query plans, 3) Reducing the number of JOINs by denormalizing data where appropriate, 4) Implementing query result caching, and 5) Using connection pooling to reduce connection overhead."
      }
    },
    {
      "id": "rel-007",
      "name": "Tangential answer - low relevance",
      "expected_score_range": "0.2-0.4",
      "event_id": "evt-rel-007",
      "event_type": "agent_response",
      "agent": {
        "name": "kg-agent",
        "type": "rag",
        "version": "1.0.0"
      },
      "interaction": {
        "user_query": "What's the syntax for creating a struct in Go?",
        "context": "Go structs are composite data types that group fields together.",
        "answer": "Go is a statically typed language developed by Google. It's known for its simplicity, concurrency support, and fast compilation times. Many developers choose Go for building microservices and cloud-native applications."
      }
    },
    {
      "id": "rel-008",
      "name": "Greeting query - appropriate response",
      "expected_score_range": "0.9-1.0",
      "event_id": "evt-rel-008",
      "event_type": "agent_response",
      "agent": {
        "name": "kg-agent",
        "type": "rag",
        "version": "1.0.0"
      },
      "interaction": {
        "user_query": "Hello! Can you help me?",
        "context": "",
        "answer": "Hello! Yes, I'd be happy to help you. I can assist with questions about Go programming, our product features, and technical documentation. What would you like to know?"
      }
    },
    {
      "id": "rel-009",
      "name": "Follow-up with pronoun - correct interpretation",
      "expected_score_range": "0.8-1.0",
      "event_id": "evt-rel-009",
      "event_type": "agent_response",
      "agent": {
        "name": "kg-agent",
        "type": "rag",
        "version": "1.0.0"
      },
      "interaction": {
        "user_query": "Can you explain that in more detail?",
        "context": "Previous conversation discussed Go's garbage collector and its tri-color mark-and-sweep algorithm. User wants more details about the GC algorithm.",
        "answer": "The Go garbage collector uses a concurrent tri-color mark-and-sweep algorithm. It works in phases: 1) Mark Setup - stops the world briefly and enables write barriers, 2) Marking - concurrent phase where it traces from roots marking reachable objects, 3) Mark Termination - stops the world to finish marking, and 4) Sweeping - concurrent phase that reclaims unmarked memory. The tri-color scheme uses white (potentially garbage), gray (being scanned), and black (reachable) sets to manage concurrent collection safely."
      }
    },
    {
      "id": "rel-010",
      "name": "Overly detailed answer - still relevant",
      "expected_score_range": "0.7-0.9",
      "event_id": "evt-rel-010",
      "event_type": "agent_response",
      "agent": {
        "name": "kg-agent",
        "type": "rag",
        "version": "1.0.0"
      },
      "interaction": {
        "user_query": "What port does the agent API run on?",
        "context": "The agent API configuration includes port settings in the .env file.",
        "answer": "The agent API runs on port 8081 by default. This is configured via the AGENT_API_PORT environment variable in your .env file. You can change this by setting AGENT_API_PORT=<your_port> in the .env file. The API uses the go-restful framework and supports OpenAPI documentation. It includes endpoints for querying, streaming responses, and admin operations like cache management. Make sure the port isn't already in use by another service, and if you're running in Docker, remember to map the port in your docker-compose.yml file."
      }
    },
    {
      "id": "rel-011",
      "name": "Yes/No question - direct answer",
      "expected_score_range": "0.9-1.0",
      "event_id": "evt-rel-011",
      "event_type": "agent_response",
      "agent": {
        "name": "kg-agent",
        "type": "rag",
        "version": "1.0.0"
      },
      "interaction": {
        "user_query": "Does the KG agent support streaming responses?",
        "context": "The KG agent has a streaming endpoint at /api/v1/query/stream that uses Server-Sent Events (SSE).",
        "answer": "Yes, the KG agent supports streaming responses through the /api/v1/query/stream endpoint using Server-Sent Events (SSE)."
      }
    },
    {
      "id": "rel-012",
      "name": "Comparison question - both aspects covered",
      "expected_score_range": "0.8-1.0",
      "event_id": "evt-rel-012",
      "event_type": "agent_response",
      "agent": {
        "name": "kg-agent",
        "type": "rag",
        "version": "1.0.0"
      },
      "interaction": {
        "user_query": "Should I use Claude Sonnet or Haiku for query rewriting?",
        "context": "Claude Sonnet (3.5) is more capable but slower and expensive. Claude Haiku (3) is faster and cheaper but less capable. Query rewriting is a relatively simple task.",
        "answer": "For query rewriting, Claude Haiku is the better choice. Query rewriting is a focused task that doesn't require Sonnet's advanced reasoning capabilities. Haiku provides ~500ms latency (vs Sonnet's ~2s), costs significantly less, and performs well for this structured transformation task. The KG agent already uses this pattern - Haiku for fast operations like validation and rewriting, Sonnet for complex reasoning with retrieved context."
      }
    },
    {
      "id": "rel-013",
      "name": "How-to question - missing steps",
      "expected_score_range": "0.3-0.5",
      "event_id": "evt-rel-013",
      "event_type": "agent_response",
      "agent": {
        "name": "kg-agent",
        "type": "rag",
        "version": "1.0.0"
      },
      "interaction": {
        "user_query": "How do I set up the vector database for the KG agent?",
        "context": "The KG agent uses PostgreSQL with pgvector extension. Setup involves running docker-compose, running migrations, and ingesting documents.",
        "answer": "You need to use PostgreSQL with the pgvector extension. The database stores document chunks with their embeddings for semantic search."
      }
    },
    {
      "id": "rel-014",
      "name": "Troubleshooting question - actionable solution",
      "expected_score_range": "0.8-1.0",
      "event_id": "evt-rel-014",
      "event_type": "agent_response",
      "agent": {
        "name": "kg-agent",
        "type": "rag",
        "version": "1.0.0"
      },
      "interaction": {
        "user_query": "Why am I getting 'connection refused' when calling the search API?",
        "context": "The search API runs on port 8082 and needs to be started separately from the agent API.",
        "answer": "The 'connection refused' error means the search API isn't running. The search API and agent API are separate services. To fix this: 1) cd into kg-agent directory, 2) Run 'docker-compose up -d' to start PostgreSQL and Redis, 3) In one terminal run 'go run cmd/search/main.go' to start the search API on port 8082, 4) In another terminal run 'go run cmd/agent/main.go' for the agent API. Verify the search API is running with 'curl http://localhost:8082/api/v1/health'."
      }
    },
    {
      "id": "rel-015",
      "name": "Conceptual question - good explanation",
      "expected_score_range": "0.8-1.0",
      "event_id": "evt-rel-015",
      "event_type": "agent_response",
      "agent": {
        "name": "kg-agent",
        "type": "rag",
        "version": "1.0.0"
      },
      "interaction": {
        "user_query": "What is retrieval augmented generation?",
        "context": "RAG is a technique that combines retrieval and generation. It retrieves relevant documents from a knowledge base and uses them to ground LLM responses.",
        "answer": "Retrieval Augmented Generation (RAG) is an AI technique that enhances language model responses by retrieving relevant information from a knowledge base before generating answers. Instead of relying solely on the model's training data, RAG first searches for pertinent documents, then provides them as context to the LLM. This reduces hallucinations, enables up-to-date information, and grounds responses in verifiable sources. The KG agent is a RAG system - it searches the vector database for relevant chunks, then passes them to Claude along with the user's query."
      }
    },
    {
      "id": "rel-016",
      "name": "Ambiguous question - wrong interpretation",
      "expected_score_range": "0.2-0.4",
      "event_id": "evt-rel-016",
      "event_type": "agent_response",
      "agent": {
        "name": "kg-agent",
        "type": "rag",
        "version": "1.0.0"
      },
      "interaction": {
        "user_query": "How do I cache it?",
        "context": "Previous conversation was about caching Docker images to speed up builds. User asked about layer caching strategies.",
        "answer": "The KG agent implements Redis-based search result caching with SHA256-keyed cache and 30-minute TTL. When the same query is executed, it returns cached results in ~50ms instead of ~500ms. You can clear the cache using the POST /api/v1/admin/cache/clear endpoint."
      }
    },
    {
      "id": "rel-017",
      "name": "Listing question - comprehensive list",
      "expected_score_range": "0.9-1.0",
      "event_id": "evt-rel-017",
      "event_type": "agent_response",
      "agent": {
        "name": "kg-agent",
        "type": "rag",
        "version": "1.0.0"
      },
      "interaction": {
        "user_query": "What judges are available in the eval-agent?",
        "context": "The eval-agent includes multiple LLM judges for different evaluation dimensions, plus heuristic prechecks.",
        "answer": "The eval-agent includes three main LLM judges: 1) RelevanceJudge - checks if the answer addresses the query, 2) FaithfulnessJudge - verifies the answer is grounded in provided context without hallucinations, and 3) CoherenceJudge - evaluates internal consistency and logical flow. Additionally, there are three heuristic prechecks (LengthChecker, OverlapChecker, FormatChecker) that run before the LLM judges to provide early-exit optimization."
      }
    },
    {
      "id": "rel-018",
      "name": "Definition question - incomplete answer",
      "expected_score_range": "0.4-0.6",
      "event_id": "evt-rel-018",
      "event_type": "agent_response",
      "agent": {
        "name": "kg-agent",
        "type": "rag",
        "version": "1.0.0"
      },
      "interaction": {
        "user_query": "What is pgvector and why do we use it?",
        "context": "pgvector is a PostgreSQL extension that adds vector similarity search capabilities. It's used for semantic search in RAG systems.",
        "answer": "pgvector is a PostgreSQL extension that enables vector operations and similarity search."
      }
    },
    {
      "id": "rel-019",
      "name": "Clarification question - context-aware answer",
      "expected_score_range": "0.8-1.0",
      "event_id": "evt-rel-019",
      "event_type": "agent_response",
      "agent": {
        "name": "kg-agent",
        "type": "rag",
        "version": "1.0.0"
      },
      "interaction": {
        "user_query": "What do you mean by 'hybrid search'?",
        "context": "Previous message mentioned that the search API uses hybrid search. User wants clarification on this term.",
        "answer": "Hybrid search in the KG agent combines two search methods: 1) Semantic search - uses pgvector cosine similarity on embeddings to find documents with similar meaning, and 2) Keyword search - uses PostgreSQL's full-text search (tsvector) for exact term matches. Results from both methods are merged using Reciprocal Rank Fusion (RRF), which balances semantic understanding with keyword precision. This gives better results than either method alone - semantic search handles synonyms and concepts, while keyword search catches specific terms."
      }
    },
    {
      "id": "rel-020",
      "name": "Off-topic with attempt to pivot",
      "expected_score_range": "0.1-0.3",
      "event_id": "evt-rel-020",
      "event_type": "agent_response",
      "agent": {
        "name": "kg-agent",
        "type": "rag",
        "version": "1.0.0"
      },
      "interaction": {
        "user_query": "Can you recommend a good Italian restaurant nearby?",
        "context": "",
        "answer": "I'm designed to help with technical questions about Go programming and our RAG agent system. However, you might want to try using Google Maps or Yelp to find Italian restaurants in your area."
      }
    }
  ]
}
